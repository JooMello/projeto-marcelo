{"version":3,"sources":["store.js"],"names":["electron","require","path","fs","Store","opts","userDataPath","app","remote","getPath","join","configName","data","parseDataFile","defaults","key","val","writeFileSync","JSON","stringify","filePath","parse","readFileSync","error","module","exports"],"mappings":";;;;;;;;AAAA,IAAMA,QAAQ,GAAGC,OAAO,CAAC,UAAD,CAAxB;;AACA,IAAMC,IAAI,GAAGD,OAAO,CAAC,MAAD,CAApB;;AACA,IAAME,EAAE,GAAGF,OAAO,CAAC,IAAD,CAAlB;;IAEMG,K;;;AACJ,iBAAYC,IAAZ,EAAkB;AAAA;;AAChB;AACA;AACA,QAAMC,YAAY,GAAG,CAACN,QAAQ,CAACO,GAAT,IAAgBP,QAAQ,CAACQ,MAAT,CAAgBD,GAAjC,EAAsCE,OAAtC,CAA8C,UAA9C,CAArB,CAHgB,CAIhB;;AACA,SAAKP,IAAL,GAAYA,IAAI,CAACQ,IAAL,CAAUJ,YAAV,EAAwBD,IAAI,CAACM,UAAL,GAAkB,OAA1C,CAAZ;AAEA,SAAKC,IAAL,GAAYC,aAAa,CAAC,KAAKX,IAAN,EAAYG,IAAI,CAACS,QAAjB,CAAzB;AACD,G,CAED;;;;;wBACIC,G,EAAK;AACP,aAAO,KAAKH,IAAL,CAAUG,GAAV,CAAP;AACD,K,CAED;;;;wBACIA,G,EAAKC,G,EAAK;AACZ,WAAKJ,IAAL,CAAUG,GAAV,IAAiBC,GAAjB,CADY,CAEZ;AACA;AACA;AACA;;AACAb,MAAAA,EAAE,CAACc,aAAH,CAAiB,KAAKf,IAAtB,EAA4BgB,IAAI,CAACC,SAAL,CAAe,KAAKP,IAApB,CAA5B;AACD;;;;;;AAGH,SAASC,aAAT,CAAuBO,QAAvB,EAAiCN,QAAjC,EAA2C;AACzC;AACA;AACA,MAAI;AACF,WAAOI,IAAI,CAACG,KAAL,CAAWlB,EAAE,CAACmB,YAAH,CAAgBF,QAAhB,CAAX,CAAP;AACD,GAFD,CAEE,OAAMG,KAAN,EAAa;AACb;AACA,WAAOT,QAAP;AACD;AACF,C,CAED;;;AACAU,MAAM,CAACC,OAAP,GAAiBrB,KAAjB","sourcesContent":["const electron = require('electron');\r\nconst path = require('path');\r\nconst fs = require('fs');\r\n\r\nclass Store {\r\n  constructor(opts) {\r\n    // Renderer process has to get `app` module via `remote`, whereas the main process can get it directly\r\n    // app.getPath('userData') will return a string of the user's app data directory path.\r\n    const userDataPath = (electron.app || electron.remote.app).getPath('userData');\r\n    // We'll use the `configName` property to set the file name and path.join to bring it all together as a string\r\n    this.path = path.join(userDataPath, opts.configName + '.json');\r\n\r\n    this.data = parseDataFile(this.path, opts.defaults);\r\n  }\r\n\r\n  // This will just return the property on the `data` object\r\n  get(key) {\r\n    return this.data[key];\r\n  }\r\n\r\n  // ...and this will set it\r\n  set(key, val) {\r\n    this.data[key] = val;\r\n    // Wait, I thought using the node.js' synchronous APIs was bad form?\r\n    // We're not writing a server so there's not nearly the same IO demand on the process\r\n    // Also if we used an async API and our app was quit before the asynchronous write had a chance to complete,\r\n    // we might lose that data. Note that in a real app, we would try/catch this.\r\n    fs.writeFileSync(this.path, JSON.stringify(this.data));\r\n  }\r\n}\r\n\r\nfunction parseDataFile(filePath, defaults) {\r\n  // We'll try/catch it in case the file doesn't exist yet, which will be the case on the first application run.\r\n  // `fs.readFileSync` will return a JSON string which we then parse into a Javascript object\r\n  try {\r\n    return JSON.parse(fs.readFileSync(filePath));\r\n  } catch(error) {\r\n    // if there was some kind of error, return the passed in defaults instead.\r\n    return defaults;\r\n  }\r\n}\r\n\r\n// expose the class\r\nmodule.exports = Store;\r\n"],"file":"store.js"}